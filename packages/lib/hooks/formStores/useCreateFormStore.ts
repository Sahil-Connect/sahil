import { create } from "zustand";

type StepDirection = "prev" | "next";

type FormState = Record<string, any>;

type FormStore = {
  currentStep: string;
  steps: readonly string[];
  goToStep: (direction: StepDirection) => void;
  updateStepByIndex: (stepIndex: number) => void;
  updateStepFormData: (formData: Record<string, any>) => void;
  formData: Record<string, number | string>;
};

/**
 * useCreateFormStore is a custom hook that creates a multi step form store with Zustand.
 * The form store includes navigation between steps, updating form data, and additional properties and methods.
 * The additional properties and methods are generated by a function passed as an argument to the hook.
 * This function receives a set function that can be used to update the state of the store.
 * The type of the additional properties and methods is specified by the generic parameter T.
 */
export const useCreateFormStore = <T extends {}>(
  initialStep: string,
  steps: readonly string[],
  // This function generates the additional properties and methods for the form store.
  // It receives a set function that can be used to update the state of the store.
  additional: (
    set: (fn: (state: FormStore & T) => FormStore & T) => void
  ) => T = () => ({} as T)
) => {
  return create<FormStore & T>((set) => {
    // Generate the additional properties and methods by calling the additional function with the set function.
    const additionalProperties = additional(set);
    return {
      currentStep: initialStep,
      formData: {},
      steps,
      ...additionalProperties,
      goToStep: (direction: StepDirection) =>
        set((state: FormState & T) => {
          const currentIndex = steps.indexOf(state.currentStep);
          const nextStep =
            direction === "next"
              ? steps[currentIndex + 1]
              : steps[currentIndex - 1];
          return nextStep ? { ...state, currentStep: nextStep } : state;
        }),
      updateStepByIndex: (stepIndex: number) =>
        set((state: FormState & T) => {
          const currentStep = steps[stepIndex];
          return currentStep ? { ...state, currentStep } : state;
        }),
      updateStepFormData: (formData: Record<string, any>) =>
        set((state: FormState & T) => ({
          ...state,
          formData: {
            ...state.formData,
            ...formData,
          },
        })),
    };
  });
};
